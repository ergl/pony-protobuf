use "format"
use "buffered"

actor Main
  new create(env: Env) =>
    try
      test_unpacked(env.out)?
      test_packed(env.out)?
    else
      env.err.print("Error parsing bytes")
    end

  fun test_unpacked(out: OutStream) ? =>
    out.print("Testing unpacked message:")
    let b0 = _UnpackedBytes()
    let obj0 = create_unpacked(b0)?
    walk_message(out, obj0)
    let b1 = bytes_for_unpacked(obj0)
    let obj1 = create_unpacked(b1)?
    walk_message(out, obj1)
    out.print("Deterministic?: " + array_eq(b0, b1).string())

  fun test_packed(out: OutStream) ? =>
    out.print("Testing packed message:")
    let b0 = _PackedBytes()
    let obj0 = create_packed(b0)?
    walk_message(out, obj0)
    let b1 = bytes_for_packed(obj0)
    let obj1 = create_packed(b1)?
    walk_message(out, obj1)
    out.print("Deterministic?: " + array_eq(b0, b1).string())

  fun create_unpacked(bytes: Array[U8] val): TestUnpacked ? =>
    let p: TestUnpacked = TestUnpacked
    p.parse_from_stream(Reader .> append(bytes)) ?
    p

  fun create_packed(bytes: Array[U8] val): TestPacked ? =>
    let p: TestPacked = TestPacked
    p.parse_from_stream(Reader .> append(bytes)) ?
    p

  fun bytes_for_unpacked(up: TestUnpacked): Array[U8] val =>
    let w: Writer = Writer
    up.write_to_stream(w)
    squash(w.done())

  fun bytes_for_packed(p: TestPacked): Array[U8] val =>
    let w: Writer = Writer
    p.write_to_stream(w)
    squash(w.done())

  fun squash(buffer: Array[ByteSeq] iso^): Array[U8] val^ =>
    recover
      let b = Array[U8](buffer.size())
      for elt in buffer.values() do
        b.append(elt)
      end
      consume b
    end

  fun array_eq(l: Array[U8] val, r: Array[U8] val): Bool =>
    if l.size() != r.size() then return false end
    for (idx, v) in l.pairs() do
      try
        if v != r(idx)? then
          return false
        end
      else
        return false
      end
    end
    true

  fun walk_message(out: OutStream, msg: (TestUnpacked | TestPacked)) =>
    let values: Array[I32] = match msg
    | let up: TestUnpacked => up.values
    | let p: TestPacked => p.values
    end
    var size = values.size()
    var idx: USize = 0
    let descr = recover String .> append("values=[") end
    for v in values.values() do
      descr.append(v.string())
      if idx < (size - 1) then
        descr.append(", ")
      end
      idx = idx + 1
    end
    descr.append("]")
    out.print(consume descr)

primitive _UnpackedBytes
  fun apply(): Array[U8] val =>
    """
    These bytes were generated by gpb_compile version 4.12.0 (erlang).

    It contains the following definiton:

    ```erlang
    #{values => lists:seq(-10, 10)}.
    ```
    """
    [
      8;246;255;255;255;255;255;255;255;255;1;8;247;255;255
      255;255;255;255;255;255;1;8;248;255;255;255;255;255;255
      255;255;1;8;249;255;255;255;255;255;255;255;255;1;8;250
      255;255;255;255;255;255;255;255;1;8;251;255;255;255;255
      255;255;255;255;1;8;252;255;255;255;255;255;255;255;255
      1;8;253;255;255;255;255;255;255;255;255;1;8;254;255;255
      255;255;255;255;255;255;1;8;255;255;255;255;255;255;255
      255;255;1;8;0;8;1;8;2;8;3;8;4;8;5;8;6;8;7;8;8;8;9;8;1
    ]

primitive _PackedBytes
  fun apply(): Array[U8] val =>
    """
    These bytes were generated by gpb_compile version 4.12.0 (erlang).

    It contains the following definiton:

    ```erlang
    #{values => lists:seq(-10, 10)}.
    ```
    """
    [
      10;111;246;255;255;255;255;255;255;255;255;1;247;255
      255;255;255;255;255;255;255;1;248;255;255;255;255;255
      255;255;255;1;249;255;255;255;255;255;255;255;255;1;250
      255;255;255;255;255;255;255;255;1;251;255;255;255;255
      255;255;255;255;1;252;255;255;255;255;255;255;255;255;1
      253;255;255;255;255;255;255;255;255;1;254;255;255;255
      255;255;255;255;255;1;255;255;255;255;255;255;255;255
      255;1;0;1;2;3;4;5;6;7;8;9;1
    ]
