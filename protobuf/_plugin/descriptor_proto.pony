// This file was autogenerated by pony-protobuf 0.1.0-a48b754 [release]. Do not edit!
// Compiled by protoc 3.17.3

use ".."

class OneofOptions is ProtoMessage
  var uninterpreted_option: Array[UninterpretedOption] = Array[UninterpretedOption]

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in uninterpreted_option.values() do
      size = size + FieldSize.inner_message(999, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (999, DelimitedField) =>
        let v: UninterpretedOption = UninterpretedOption
        v.parse_from_stream(reader.pop_embed()?)?
        uninterpreted_option.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in uninterpreted_option.values() do
      writer.write_tag(999, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in uninterpreted_option.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class OneofDescriptorProto is ProtoMessage
  var name: (String | None) = None
  var options: (OneofOptions | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    match name
    | None => None
    | let name': String =>
      size = size + FieldSize.delimited(1, name')
    end
    match options
    | None => None
    | let options': this->OneofOptions =>
      size = size + FieldSize.inner_message(2, options')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        name = reader.read_string()?
      | (2, DelimitedField) =>
        match options
        | None =>
          options = OneofOptions.>parse_from_stream(reader.pop_embed()?)?
        | let options': OneofOptions =>
          options'.parse_from_stream(reader.pop_embed()?)?
        end
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match name
    | None => None
    | let name': String =>
      writer.write_tag(1, DelimitedField)
      writer.write_bytes(name')
    end
    match options
    | None => None
    | let options': this->OneofOptions =>
      writer.write_tag(2, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](options'.compute_size())
      options'.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    match options
    | None => None
    | let options': this->OneofOptions =>
      if not (options'.is_initialized()) then
        return false
      end
    end
    true

class ExtensionRangeOptions is ProtoMessage
  var uninterpreted_option: Array[UninterpretedOption] = Array[UninterpretedOption]

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in uninterpreted_option.values() do
      size = size + FieldSize.inner_message(999, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (999, DelimitedField) =>
        let v: UninterpretedOption = UninterpretedOption
        v.parse_from_stream(reader.pop_embed()?)?
        uninterpreted_option.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in uninterpreted_option.values() do
      writer.write_tag(999, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in uninterpreted_option.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class DescriptorProtoExtensionRange is ProtoMessage
  var start: (I32 | None) = None
  var end_field: (I32 | None) = None
  var options: (ExtensionRangeOptions | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    match start
    | None => None
    | let start': I32 =>
      size = size + FieldSize.varint[I32](1, start')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      size = size + FieldSize.varint[I32](2, end_field')
    end
    match options
    | None => None
    | let options': this->ExtensionRangeOptions =>
      size = size + FieldSize.inner_message(3, options')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, VarintField) =>
        start = reader.read_varint_32()?.i32()
      | (2, VarintField) =>
        end_field = reader.read_varint_32()?.i32()
      | (3, DelimitedField) =>
        match options
        | None =>
          options = ExtensionRangeOptions.>parse_from_stream(reader.pop_embed()?)?
        | let options': ExtensionRangeOptions =>
          options'.parse_from_stream(reader.pop_embed()?)?
        end
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match start
    | None => None
    | let start': I32 =>
      writer.write_tag(1, VarintField)
      writer.write_varint[I32](start')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      writer.write_tag(2, VarintField)
      writer.write_varint[I32](end_field')
    end
    match options
    | None => None
    | let options': this->ExtensionRangeOptions =>
      writer.write_tag(3, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](options'.compute_size())
      options'.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    match options
    | None => None
    | let options': this->ExtensionRangeOptions =>
      if not (options'.is_initialized()) then
        return false
      end
    end
    true

class DescriptorProtoReservedRange is ProtoMessage
  var start: (I32 | None) = None
  var end_field: (I32 | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    match start
    | None => None
    | let start': I32 =>
      size = size + FieldSize.varint[I32](1, start')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      size = size + FieldSize.varint[I32](2, end_field')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, VarintField) =>
        start = reader.read_varint_32()?.i32()
      | (2, VarintField) =>
        end_field = reader.read_varint_32()?.i32()
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match start
    | None => None
    | let start': I32 =>
      writer.write_tag(1, VarintField)
      writer.write_varint[I32](start')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      writer.write_tag(2, VarintField)
      writer.write_varint[I32](end_field')
    end

class MessageOptions is ProtoMessage
  var message_set_wire_format: (Bool | None) = false
  var no_standard_descriptor_accessor: (Bool | None) = false
  var deprecated: (Bool | None) = false
  var map_entry: (Bool | None) = None
  var uninterpreted_option: Array[UninterpretedOption] = Array[UninterpretedOption]

  fun compute_size(): U32 =>
    var size: U32 = 0
    match message_set_wire_format
    | None => None
    | let message_set_wire_format': Bool =>
      size = size + FieldSize.varint[Bool](1, message_set_wire_format')
    end
    match no_standard_descriptor_accessor
    | None => None
    | let no_standard_descriptor_accessor': Bool =>
      size = size + FieldSize.varint[Bool](2, no_standard_descriptor_accessor')
    end
    match deprecated
    | None => None
    | let deprecated': Bool =>
      size = size + FieldSize.varint[Bool](3, deprecated')
    end
    match map_entry
    | None => None
    | let map_entry': Bool =>
      size = size + FieldSize.varint[Bool](7, map_entry')
    end
    for v in uninterpreted_option.values() do
      size = size + FieldSize.inner_message(999, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, VarintField) =>
        message_set_wire_format = reader.read_varint_bool()?
      | (2, VarintField) =>
        no_standard_descriptor_accessor = reader.read_varint_bool()?
      | (3, VarintField) =>
        deprecated = reader.read_varint_bool()?
      | (7, VarintField) =>
        map_entry = reader.read_varint_bool()?
      | (999, DelimitedField) =>
        let v: UninterpretedOption = UninterpretedOption
        v.parse_from_stream(reader.pop_embed()?)?
        uninterpreted_option.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match message_set_wire_format
    | None => None
    | let message_set_wire_format': Bool =>
      writer.write_tag(1, VarintField)
      writer.write_varint[Bool](message_set_wire_format')
    end
    match no_standard_descriptor_accessor
    | None => None
    | let no_standard_descriptor_accessor': Bool =>
      writer.write_tag(2, VarintField)
      writer.write_varint[Bool](no_standard_descriptor_accessor')
    end
    match deprecated
    | None => None
    | let deprecated': Bool =>
      writer.write_tag(3, VarintField)
      writer.write_varint[Bool](deprecated')
    end
    match map_entry
    | None => None
    | let map_entry': Bool =>
      writer.write_tag(7, VarintField)
      writer.write_varint[Bool](map_entry')
    end
    for v in uninterpreted_option.values() do
      writer.write_tag(999, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in uninterpreted_option.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class DescriptorProto is ProtoMessage
  var name: (String | None) = None
  var field: Array[FieldDescriptorProto] = Array[FieldDescriptorProto]
  var nested_type: Array[DescriptorProto] = Array[DescriptorProto]
  var enum_type: Array[EnumDescriptorProto] = Array[EnumDescriptorProto]
  var extension_range: Array[DescriptorProtoExtensionRange] = Array[DescriptorProtoExtensionRange]
  var extension: Array[FieldDescriptorProto] = Array[FieldDescriptorProto]
  var options: (MessageOptions | None) = None
  var oneof_decl: Array[OneofDescriptorProto] = Array[OneofDescriptorProto]
  var reserved_range: Array[DescriptorProtoReservedRange] = Array[DescriptorProtoReservedRange]
  var reserved_name: Array[String] = Array[String]

  fun compute_size(): U32 =>
    var size: U32 = 0
    match name
    | None => None
    | let name': String =>
      size = size + FieldSize.delimited(1, name')
    end
    for v in field.values() do
      size = size + FieldSize.inner_message(2, v)
    end
    for v in nested_type.values() do
      size = size + FieldSize.inner_message(3, v)
    end
    for v in enum_type.values() do
      size = size + FieldSize.inner_message(4, v)
    end
    for v in extension_range.values() do
      size = size + FieldSize.inner_message(5, v)
    end
    for v in extension.values() do
      size = size + FieldSize.inner_message(6, v)
    end
    match options
    | None => None
    | let options': this->MessageOptions =>
      size = size + FieldSize.inner_message(7, options')
    end
    for v in oneof_decl.values() do
      size = size + FieldSize.inner_message(8, v)
    end
    for v in reserved_range.values() do
      size = size + FieldSize.inner_message(9, v)
    end
    for v in reserved_name.values() do
      size = size + FieldSize.delimited(10, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        name = reader.read_string()?
      | (2, DelimitedField) =>
        let v: FieldDescriptorProto = FieldDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        field.push(v)
      | (3, DelimitedField) =>
        let v: DescriptorProto = DescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        nested_type.push(v)
      | (4, DelimitedField) =>
        let v: EnumDescriptorProto = EnumDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        enum_type.push(v)
      | (5, DelimitedField) =>
        let v: DescriptorProtoExtensionRange = DescriptorProtoExtensionRange
        v.parse_from_stream(reader.pop_embed()?)?
        extension_range.push(v)
      | (6, DelimitedField) =>
        let v: FieldDescriptorProto = FieldDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        extension.push(v)
      | (7, DelimitedField) =>
        match options
        | None =>
          options = MessageOptions.>parse_from_stream(reader.pop_embed()?)?
        | let options': MessageOptions =>
          options'.parse_from_stream(reader.pop_embed()?)?
        end
      | (8, DelimitedField) =>
        let v: OneofDescriptorProto = OneofDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        oneof_decl.push(v)
      | (9, DelimitedField) =>
        let v: DescriptorProtoReservedRange = DescriptorProtoReservedRange
        v.parse_from_stream(reader.pop_embed()?)?
        reserved_range.push(v)
      | (10, DelimitedField) =>
        reserved_name.push(reader.read_string()?)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match name
    | None => None
    | let name': String =>
      writer.write_tag(1, DelimitedField)
      writer.write_bytes(name')
    end
    for v in field.values() do
      writer.write_tag(2, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in nested_type.values() do
      writer.write_tag(3, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in enum_type.values() do
      writer.write_tag(4, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in extension_range.values() do
      writer.write_tag(5, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in extension.values() do
      writer.write_tag(6, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    match options
    | None => None
    | let options': this->MessageOptions =>
      writer.write_tag(7, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](options'.compute_size())
      options'.write_to_stream(writer)
    end
    for v in oneof_decl.values() do
      writer.write_tag(8, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in reserved_range.values() do
      writer.write_tag(9, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in reserved_name.values() do
      writer.write_tag(10, DelimitedField)
      writer.write_bytes(v)
    end

  fun is_initialized(): Bool =>
    for v in field.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in nested_type.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in enum_type.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in extension_range.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in extension.values() do
      if not v.is_initialized() then
        return false
      end
    end
    match options
    | None => None
    | let options': this->MessageOptions =>
      if not (options'.is_initialized()) then
        return false
      end
    end
    for v in oneof_decl.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in reserved_range.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true
