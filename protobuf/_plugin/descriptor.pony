// This file was autogenerated by pony-protobuf 0.1.0-a48b754 [release]. Do not edit!
// Compiled by protoc 3.17.3

use ".."

class FileDescriptorSet is ProtoMessage
  var file: Array[FileDescriptorProto] = Array[FileDescriptorProto]

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in file.values() do
      size = size + FieldSize.inner_message(1, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        let v: FileDescriptorProto = FileDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        file.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in file.values() do
      writer.write_tag(1, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in file.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class FileDescriptorProto is ProtoMessage
  var name: (String | None) = None
  var package: (String | None) = None
  var dependency: Array[String] = Array[String]
  var message_type: Array[DescriptorProto] = Array[DescriptorProto]
  var enum_type: Array[EnumDescriptorProto] = Array[EnumDescriptorProto]
  var extension: Array[FieldDescriptorProto] = Array[FieldDescriptorProto]
  var options: (FileOptions | None) = None
  var source_code_info: (SourceCodeInfo | None) = None
  var public_dependency: Array[I32] = Array[I32]
  var weak_dependency: Array[I32] = Array[I32]
  var syntax: (String | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    match name
    | None => None
    | let name': String =>
      size = size + FieldSize.delimited(1, name')
    end
    match package
    | None => None
    | let package': String =>
      size = size + FieldSize.delimited(2, package')
    end
    for v in dependency.values() do
      size = size + FieldSize.delimited(3, v)
    end
    for v in message_type.values() do
      size = size + FieldSize.inner_message(4, v)
    end
    for v in enum_type.values() do
      size = size + FieldSize.inner_message(5, v)
    end
    for v in extension.values() do
      size = size + FieldSize.inner_message(7, v)
    end
    match options
    | None => None
    | let options': this->FileOptions =>
      size = size + FieldSize.inner_message(8, options')
    end
    match source_code_info
    | None => None
    | let source_code_info': this->SourceCodeInfo =>
      size = size + FieldSize.inner_message(9, source_code_info')
    end
    for v in public_dependency.values() do
      size = size + FieldSize.varint[I32](10, v)
    end
    for v in weak_dependency.values() do
      size = size + FieldSize.varint[I32](11, v)
    end
    match syntax
    | None => None
    | let syntax': String =>
      size = size + FieldSize.delimited(12, syntax')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        name = reader.read_string()?
      | (2, DelimitedField) =>
        package = reader.read_string()?
      | (3, DelimitedField) =>
        dependency.push(reader.read_string()?)
      | (4, DelimitedField) =>
        let v: DescriptorProto = DescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        message_type.push(v)
      | (5, DelimitedField) =>
        let v: EnumDescriptorProto = EnumDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        enum_type.push(v)
      | (7, DelimitedField) =>
        let v: FieldDescriptorProto = FieldDescriptorProto
        v.parse_from_stream(reader.pop_embed()?)?
        extension.push(v)
      | (8, DelimitedField) =>
        match options
        | None =>
          options = FileOptions.>parse_from_stream(reader.pop_embed()?)?
        | let options': FileOptions =>
          options'.parse_from_stream(reader.pop_embed()?)?
        end
      | (9, DelimitedField) =>
        match source_code_info
        | None =>
          source_code_info = SourceCodeInfo.>parse_from_stream(reader.pop_embed()?)?
        | let source_code_info': SourceCodeInfo =>
          source_code_info'.parse_from_stream(reader.pop_embed()?)?
        end
      | (10, VarintField) =>
        public_dependency.push(reader.read_varint_32()?.i32())
      | (11, VarintField) =>
        weak_dependency.push(reader.read_varint_32()?.i32())
      | (12, DelimitedField) =>
        syntax = reader.read_string()?
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match name
    | None => None
    | let name': String =>
      writer.write_tag(1, DelimitedField)
      writer.write_bytes(name')
    end
    match package
    | None => None
    | let package': String =>
      writer.write_tag(2, DelimitedField)
      writer.write_bytes(package')
    end
    for v in dependency.values() do
      writer.write_tag(3, DelimitedField)
      writer.write_bytes(v)
    end
    for v in message_type.values() do
      writer.write_tag(4, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in enum_type.values() do
      writer.write_tag(5, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    for v in extension.values() do
      writer.write_tag(7, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    match options
    | None => None
    | let options': this->FileOptions =>
      writer.write_tag(8, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](options'.compute_size())
      options'.write_to_stream(writer)
    end
    match source_code_info
    | None => None
    | let source_code_info': this->SourceCodeInfo =>
      writer.write_tag(9, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](source_code_info'.compute_size())
      source_code_info'.write_to_stream(writer)
    end
    for v in public_dependency.values() do
      writer.write_tag(10, VarintField)
      writer.write_varint[I32](v)
    end
    for v in weak_dependency.values() do
      writer.write_tag(11, VarintField)
      writer.write_varint[I32](v)
    end
    match syntax
    | None => None
    | let syntax': String =>
      writer.write_tag(12, DelimitedField)
      writer.write_bytes(syntax')
    end

  fun is_initialized(): Bool =>
    for v in message_type.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in enum_type.values() do
      if not v.is_initialized() then
        return false
      end
    end
    for v in extension.values() do
      if not v.is_initialized() then
        return false
      end
    end
    match options
    | None => None
    | let options': this->FileOptions =>
      if not (options'.is_initialized()) then
        return false
      end
    end
    match source_code_info
    | None => None
    | let source_code_info': this->SourceCodeInfo =>
      if not (source_code_info'.is_initialized()) then
        return false
      end
    end
    true

primitive FileOptionsOptimizeModeSPEED is ProtoEnumValue
  fun as_i32(): I32 => 1
  fun string(): String => "FileOptionsOptimizeModeSPEED"

primitive FileOptionsOptimizeModeCODESIZE is ProtoEnumValue
  fun as_i32(): I32 => 2
  fun string(): String => "FileOptionsOptimizeModeCODESIZE"

primitive FileOptionsOptimizeModeLITERUNTIME is ProtoEnumValue
  fun as_i32(): I32 => 3
  fun string(): String => "FileOptionsOptimizeModeLITERUNTIME"

type FileOptionsOptimizeMode is (
  FileOptionsOptimizeModeSPEED
  | FileOptionsOptimizeModeCODESIZE
  | FileOptionsOptimizeModeLITERUNTIME
)

primitive FileOptionsOptimizeModeBuilder is ProtoEnum
  fun from_i32(value: I32): (FileOptionsOptimizeMode | None) =>
    match value
    | 1 => FileOptionsOptimizeModeSPEED
    | 2 => FileOptionsOptimizeModeCODESIZE
    | 3 => FileOptionsOptimizeModeLITERUNTIME
    else
      None
    end

class FileOptions is ProtoMessage
  var java_package: (String | None) = None
  var java_outer_classname: (String | None) = None
  var optimize_for: (FileOptionsOptimizeMode | None) = FileOptionsOptimizeModeSPEED
  var java_multiple_files: (Bool | None) = false
  var go_package: (String | None) = None
  var cc_generic_services: (Bool | None) = false
  var java_generic_services: (Bool | None) = false
  var py_generic_services: (Bool | None) = false
  var java_generate_equals_and_hash: (Bool | None) = None
  var deprecated: (Bool | None) = false
  var java_string_check_utf8: (Bool | None) = false
  var cc_enable_arenas: (Bool | None) = true
  var objc_class_prefix: (String | None) = None
  var csharp_namespace: (String | None) = None
  var swift_prefix: (String | None) = None
  var php_class_prefix: (String | None) = None
  var php_namespace: (String | None) = None
  var php_generic_services: (Bool | None) = false
  var php_metadata_namespace: (String | None) = None
  var ruby_package: (String | None) = None
  var uninterpreted_option: Array[UninterpretedOption] = Array[UninterpretedOption]

  fun compute_size(): U32 =>
    var size: U32 = 0
    match java_package
    | None => None
    | let java_package': String =>
      size = size + FieldSize.delimited(1, java_package')
    end
    match java_outer_classname
    | None => None
    | let java_outer_classname': String =>
      size = size + FieldSize.delimited(8, java_outer_classname')
    end
    match optimize_for
    | None => None
    | let optimize_for': FileOptionsOptimizeMode =>
      size = size + FieldSize.enum(9, optimize_for')
    end
    match java_multiple_files
    | None => None
    | let java_multiple_files': Bool =>
      size = size + FieldSize.varint[Bool](10, java_multiple_files')
    end
    match go_package
    | None => None
    | let go_package': String =>
      size = size + FieldSize.delimited(11, go_package')
    end
    match cc_generic_services
    | None => None
    | let cc_generic_services': Bool =>
      size = size + FieldSize.varint[Bool](16, cc_generic_services')
    end
    match java_generic_services
    | None => None
    | let java_generic_services': Bool =>
      size = size + FieldSize.varint[Bool](17, java_generic_services')
    end
    match py_generic_services
    | None => None
    | let py_generic_services': Bool =>
      size = size + FieldSize.varint[Bool](18, py_generic_services')
    end
    match java_generate_equals_and_hash
    | None => None
    | let java_generate_equals_and_hash': Bool =>
      size = size + FieldSize.varint[Bool](20, java_generate_equals_and_hash')
    end
    match deprecated
    | None => None
    | let deprecated': Bool =>
      size = size + FieldSize.varint[Bool](23, deprecated')
    end
    match java_string_check_utf8
    | None => None
    | let java_string_check_utf8': Bool =>
      size = size + FieldSize.varint[Bool](27, java_string_check_utf8')
    end
    match cc_enable_arenas
    | None => None
    | let cc_enable_arenas': Bool =>
      size = size + FieldSize.varint[Bool](31, cc_enable_arenas')
    end
    match objc_class_prefix
    | None => None
    | let objc_class_prefix': String =>
      size = size + FieldSize.delimited(36, objc_class_prefix')
    end
    match csharp_namespace
    | None => None
    | let csharp_namespace': String =>
      size = size + FieldSize.delimited(37, csharp_namespace')
    end
    match swift_prefix
    | None => None
    | let swift_prefix': String =>
      size = size + FieldSize.delimited(39, swift_prefix')
    end
    match php_class_prefix
    | None => None
    | let php_class_prefix': String =>
      size = size + FieldSize.delimited(40, php_class_prefix')
    end
    match php_namespace
    | None => None
    | let php_namespace': String =>
      size = size + FieldSize.delimited(41, php_namespace')
    end
    match php_generic_services
    | None => None
    | let php_generic_services': Bool =>
      size = size + FieldSize.varint[Bool](42, php_generic_services')
    end
    match php_metadata_namespace
    | None => None
    | let php_metadata_namespace': String =>
      size = size + FieldSize.delimited(44, php_metadata_namespace')
    end
    match ruby_package
    | None => None
    | let ruby_package': String =>
      size = size + FieldSize.delimited(45, ruby_package')
    end
    for v in uninterpreted_option.values() do
      size = size + FieldSize.inner_message(999, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        java_package = reader.read_string()?
      | (8, DelimitedField) =>
        java_outer_classname = reader.read_string()?
      | (9, VarintField) =>
        optimize_for = FileOptionsOptimizeModeBuilder.from_i32(reader.read_varint_32()?.i32())
      | (10, VarintField) =>
        java_multiple_files = reader.read_varint_bool()?
      | (11, DelimitedField) =>
        go_package = reader.read_string()?
      | (16, VarintField) =>
        cc_generic_services = reader.read_varint_bool()?
      | (17, VarintField) =>
        java_generic_services = reader.read_varint_bool()?
      | (18, VarintField) =>
        py_generic_services = reader.read_varint_bool()?
      | (20, VarintField) =>
        java_generate_equals_and_hash = reader.read_varint_bool()?
      | (23, VarintField) =>
        deprecated = reader.read_varint_bool()?
      | (27, VarintField) =>
        java_string_check_utf8 = reader.read_varint_bool()?
      | (31, VarintField) =>
        cc_enable_arenas = reader.read_varint_bool()?
      | (36, DelimitedField) =>
        objc_class_prefix = reader.read_string()?
      | (37, DelimitedField) =>
        csharp_namespace = reader.read_string()?
      | (39, DelimitedField) =>
        swift_prefix = reader.read_string()?
      | (40, DelimitedField) =>
        php_class_prefix = reader.read_string()?
      | (41, DelimitedField) =>
        php_namespace = reader.read_string()?
      | (42, VarintField) =>
        php_generic_services = reader.read_varint_bool()?
      | (44, DelimitedField) =>
        php_metadata_namespace = reader.read_string()?
      | (45, DelimitedField) =>
        ruby_package = reader.read_string()?
      | (999, DelimitedField) =>
        let v: UninterpretedOption = UninterpretedOption
        v.parse_from_stream(reader.pop_embed()?)?
        uninterpreted_option.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match java_package
    | None => None
    | let java_package': String =>
      writer.write_tag(1, DelimitedField)
      writer.write_bytes(java_package')
    end
    match java_outer_classname
    | None => None
    | let java_outer_classname': String =>
      writer.write_tag(8, DelimitedField)
      writer.write_bytes(java_outer_classname')
    end
    match optimize_for
    | None => None
    | let optimize_for': FileOptionsOptimizeMode =>
      writer.write_tag(9, VarintField)
      writer.write_enum(optimize_for')
    end
    match java_multiple_files
    | None => None
    | let java_multiple_files': Bool =>
      writer.write_tag(10, VarintField)
      writer.write_varint[Bool](java_multiple_files')
    end
    match go_package
    | None => None
    | let go_package': String =>
      writer.write_tag(11, DelimitedField)
      writer.write_bytes(go_package')
    end
    match cc_generic_services
    | None => None
    | let cc_generic_services': Bool =>
      writer.write_tag(16, VarintField)
      writer.write_varint[Bool](cc_generic_services')
    end
    match java_generic_services
    | None => None
    | let java_generic_services': Bool =>
      writer.write_tag(17, VarintField)
      writer.write_varint[Bool](java_generic_services')
    end
    match py_generic_services
    | None => None
    | let py_generic_services': Bool =>
      writer.write_tag(18, VarintField)
      writer.write_varint[Bool](py_generic_services')
    end
    match java_generate_equals_and_hash
    | None => None
    | let java_generate_equals_and_hash': Bool =>
      writer.write_tag(20, VarintField)
      writer.write_varint[Bool](java_generate_equals_and_hash')
    end
    match deprecated
    | None => None
    | let deprecated': Bool =>
      writer.write_tag(23, VarintField)
      writer.write_varint[Bool](deprecated')
    end
    match java_string_check_utf8
    | None => None
    | let java_string_check_utf8': Bool =>
      writer.write_tag(27, VarintField)
      writer.write_varint[Bool](java_string_check_utf8')
    end
    match cc_enable_arenas
    | None => None
    | let cc_enable_arenas': Bool =>
      writer.write_tag(31, VarintField)
      writer.write_varint[Bool](cc_enable_arenas')
    end
    match objc_class_prefix
    | None => None
    | let objc_class_prefix': String =>
      writer.write_tag(36, DelimitedField)
      writer.write_bytes(objc_class_prefix')
    end
    match csharp_namespace
    | None => None
    | let csharp_namespace': String =>
      writer.write_tag(37, DelimitedField)
      writer.write_bytes(csharp_namespace')
    end
    match swift_prefix
    | None => None
    | let swift_prefix': String =>
      writer.write_tag(39, DelimitedField)
      writer.write_bytes(swift_prefix')
    end
    match php_class_prefix
    | None => None
    | let php_class_prefix': String =>
      writer.write_tag(40, DelimitedField)
      writer.write_bytes(php_class_prefix')
    end
    match php_namespace
    | None => None
    | let php_namespace': String =>
      writer.write_tag(41, DelimitedField)
      writer.write_bytes(php_namespace')
    end
    match php_generic_services
    | None => None
    | let php_generic_services': Bool =>
      writer.write_tag(42, VarintField)
      writer.write_varint[Bool](php_generic_services')
    end
    match php_metadata_namespace
    | None => None
    | let php_metadata_namespace': String =>
      writer.write_tag(44, DelimitedField)
      writer.write_bytes(php_metadata_namespace')
    end
    match ruby_package
    | None => None
    | let ruby_package': String =>
      writer.write_tag(45, DelimitedField)
      writer.write_bytes(ruby_package')
    end
    for v in uninterpreted_option.values() do
      writer.write_tag(999, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in uninterpreted_option.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class UninterpretedOptionNamePart is ProtoMessage
  var name_part: (String | None) = None
  var is_extension: (Bool | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    match name_part
    | None => None
    | let name_part': String =>
      size = size + FieldSize.delimited(1, name_part')
    end
    match is_extension
    | None => None
    | let is_extension': Bool =>
      size = size + FieldSize.varint[Bool](2, is_extension')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        name_part = reader.read_string()?
      | (2, VarintField) =>
        is_extension = reader.read_varint_bool()?
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    match name_part
    | None => None
    | let name_part': String =>
      writer.write_tag(1, DelimitedField)
      writer.write_bytes(name_part')
    end
    match is_extension
    | None => None
    | let is_extension': Bool =>
      writer.write_tag(2, VarintField)
      writer.write_varint[Bool](is_extension')
    end

  fun is_initialized(): Bool =>
    if name_part is None then
      return false
    end
    if is_extension is None then
      return false
    end
    true

class UninterpretedOption is ProtoMessage
  var name: Array[UninterpretedOptionNamePart] = Array[UninterpretedOptionNamePart]
  var identifier_value: (String | None) = None
  var positive_int_value: (U64 | None) = None
  var negative_int_value: (I64 | None) = None
  var double_value: (F64 | None) = None
  var string_value: (Array[U8] | None) = None
  var aggregate_value: (String | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in name.values() do
      size = size + FieldSize.inner_message(2, v)
    end
    match identifier_value
    | None => None
    | let identifier_value': String =>
      size = size + FieldSize.delimited(3, identifier_value')
    end
    match positive_int_value
    | None => None
    | let positive_int_value': U64 =>
      size = size + FieldSize.varint[U64](4, positive_int_value')
    end
    match negative_int_value
    | None => None
    | let negative_int_value': I64 =>
      size = size + FieldSize.varint[I64](5, negative_int_value')
    end
    match double_value
    | None => None
    | let double_value': F64 =>
      size = size + FieldSize.fixed64(6)
    end
    match string_value
    | None => None
    | let string_value': this->Array[U8] =>
      size = size + FieldSize.delimited(7, string_value')
    end
    match aggregate_value
    | None => None
    | let aggregate_value': String =>
      size = size + FieldSize.delimited(8, aggregate_value')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (2, DelimitedField) =>
        let v: UninterpretedOptionNamePart = UninterpretedOptionNamePart
        v.parse_from_stream(reader.pop_embed()?)?
        name.push(v)
      | (3, DelimitedField) =>
        identifier_value = reader.read_string()?
      | (4, VarintField) =>
        positive_int_value = reader.read_varint_64()?
      | (5, VarintField) =>
        negative_int_value = reader.read_varint_64()?.i64()
      | (6, Fixed64Field) =>
        double_value = reader.read_fixed_64_float()?
      | (7, DelimitedField) =>
        string_value = reader.read_bytes()?
      | (8, DelimitedField) =>
        aggregate_value = reader.read_string()?
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in name.values() do
      writer.write_tag(2, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end
    match identifier_value
    | None => None
    | let identifier_value': String =>
      writer.write_tag(3, DelimitedField)
      writer.write_bytes(identifier_value')
    end
    match positive_int_value
    | None => None
    | let positive_int_value': U64 =>
      writer.write_tag(4, VarintField)
      writer.write_varint[U64](positive_int_value')
    end
    match negative_int_value
    | None => None
    | let negative_int_value': I64 =>
      writer.write_tag(5, VarintField)
      writer.write_varint[I64](negative_int_value')
    end
    match double_value
    | None => None
    | let double_value': F64 =>
      writer.write_tag(6, Fixed32Field)
      writer.write_fixed_64[F64](double_value')
    end
    match string_value
    | None => None
    | let string_value': this->Array[U8] =>
      writer.write_tag(7, DelimitedField)
      writer.write_bytes(string_value')
    end
    match aggregate_value
    | None => None
    | let aggregate_value': String =>
      writer.write_tag(8, DelimitedField)
      writer.write_bytes(aggregate_value')
    end

  fun is_initialized(): Bool =>
    for v in name.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class SourceCodeInfoLocation is ProtoMessage
  var path: Array[I32] = Array[I32]
  var span: Array[I32] = Array[I32]
  var leading_comments: (String | None) = None
  var trailing_comments: (String | None) = None
  var leading_detached_comments: Array[String] = Array[String]

  fun compute_size(): U32 =>
    var size: U32 = 0
    size = size + FieldSize.packed_varint[I32](1, path)
    size = size + FieldSize.packed_varint[I32](2, span)
    match leading_comments
    | None => None
    | let leading_comments': String =>
      size = size + FieldSize.delimited(3, leading_comments')
    end
    match trailing_comments
    | None => None
    | let trailing_comments': String =>
      size = size + FieldSize.delimited(4, trailing_comments')
    end
    for v in leading_detached_comments.values() do
      size = size + FieldSize.delimited(6, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        reader.read_packed_varint[I32](path)?
      | (1, VarintField) =>
        let v = reader.read_varint_32()?.i32()
        path.push(v)
      | (2, DelimitedField) =>
        reader.read_packed_varint[I32](span)?
      | (2, VarintField) =>
        let v = reader.read_varint_32()?.i32()
        span.push(v)
      | (3, DelimitedField) =>
        leading_comments = reader.read_string()?
      | (4, DelimitedField) =>
        trailing_comments = reader.read_string()?
      | (6, DelimitedField) =>
        leading_detached_comments.push(reader.read_string()?)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    if path.size() != 0 then
      var path_size: U32 = 0
      for v in path.values() do
        path_size = path_size + FieldSize.raw_varint(v.u64())
      end
      writer.write_tag(1, DelimitedField)
      writer.write_packed_varint[I32](path, path_size)
    end
    if span.size() != 0 then
      var span_size: U32 = 0
      for v in span.values() do
        span_size = span_size + FieldSize.raw_varint(v.u64())
      end
      writer.write_tag(2, DelimitedField)
      writer.write_packed_varint[I32](span, span_size)
    end
    match leading_comments
    | None => None
    | let leading_comments': String =>
      writer.write_tag(3, DelimitedField)
      writer.write_bytes(leading_comments')
    end
    match trailing_comments
    | None => None
    | let trailing_comments': String =>
      writer.write_tag(4, DelimitedField)
      writer.write_bytes(trailing_comments')
    end
    for v in leading_detached_comments.values() do
      writer.write_tag(6, DelimitedField)
      writer.write_bytes(v)
    end

class SourceCodeInfo is ProtoMessage
  var location: Array[SourceCodeInfoLocation] = Array[SourceCodeInfoLocation]

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in location.values() do
      size = size + FieldSize.inner_message(1, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        let v: SourceCodeInfoLocation = SourceCodeInfoLocation
        v.parse_from_stream(reader.pop_embed()?)?
        location.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in location.values() do
      writer.write_tag(1, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in location.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true

class GeneratedCodeInfoAnnotation is ProtoMessage
  var path: Array[I32] = Array[I32]
  var source_file: (String | None) = None
  var begin: (I32 | None) = None
  var end_field: (I32 | None) = None

  fun compute_size(): U32 =>
    var size: U32 = 0
    size = size + FieldSize.packed_varint[I32](1, path)
    match source_file
    | None => None
    | let source_file': String =>
      size = size + FieldSize.delimited(2, source_file')
    end
    match begin
    | None => None
    | let begin': I32 =>
      size = size + FieldSize.varint[I32](3, begin')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      size = size + FieldSize.varint[I32](4, end_field')
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        reader.read_packed_varint[I32](path)?
      | (1, VarintField) =>
        let v = reader.read_varint_32()?.i32()
        path.push(v)
      | (2, DelimitedField) =>
        source_file = reader.read_string()?
      | (3, VarintField) =>
        begin = reader.read_varint_32()?.i32()
      | (4, VarintField) =>
        end_field = reader.read_varint_32()?.i32()
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    if path.size() != 0 then
      var path_size: U32 = 0
      for v in path.values() do
        path_size = path_size + FieldSize.raw_varint(v.u64())
      end
      writer.write_tag(1, DelimitedField)
      writer.write_packed_varint[I32](path, path_size)
    end
    match source_file
    | None => None
    | let source_file': String =>
      writer.write_tag(2, DelimitedField)
      writer.write_bytes(source_file')
    end
    match begin
    | None => None
    | let begin': I32 =>
      writer.write_tag(3, VarintField)
      writer.write_varint[I32](begin')
    end
    match end_field
    | None => None
    | let end_field': I32 =>
      writer.write_tag(4, VarintField)
      writer.write_varint[I32](end_field')
    end

class GeneratedCodeInfo is ProtoMessage
  var annotation: Array[GeneratedCodeInfoAnnotation] = Array[GeneratedCodeInfoAnnotation]

  fun compute_size(): U32 =>
    var size: U32 = 0
    for v in annotation.values() do
      size = size + FieldSize.inner_message(1, v)
    end
    size

  fun ref parse_from_stream(reader: ProtoReader) ? =>
    while reader.size() > 0 do
      match reader.read_field_tag()?
      | (1, DelimitedField) =>
        let v: GeneratedCodeInfoAnnotation = GeneratedCodeInfoAnnotation
        v.parse_from_stream(reader.pop_embed()?)?
        annotation.push(v)
      | (_, let typ: TagKind) => reader.skip_field(typ)?
      end
    end

  fun write_to_stream(writer: ProtoWriter) =>
    for v in annotation.values() do
      writer.write_tag(1, DelimitedField)
      // TODO: Don't recompute size here, it's wasteful
      writer.write_varint[U32](v.compute_size())
      v.write_to_stream(writer)
    end

  fun is_initialized(): Bool =>
    for v in annotation.values() do
      if not v.is_initialized() then
        return false
      end
    end
    true
